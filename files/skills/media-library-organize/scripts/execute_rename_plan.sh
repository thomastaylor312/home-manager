#!/usr/bin/env bash
set -euo pipefail

usage() {
  cat <<'EOF' >&2
Execute a rename plan generated by generate_rename_plan.sh.

Moves files from the top level of the source directory into the organized
subdirectory structure (Movies/ or Shows/).

Usage:
  execute_rename_plan.sh [OPTIONS] PLAN_FILE

Options:
  --dry-run             Show what would be done without making changes
  --force               Overwrite existing files (default: skip with warning)

The plan file should be JSON output from generate_rename_plan.sh.

Examples:
  execute_rename_plan.sh rename_plan.json
  execute_rename_plan.sh --dry-run rename_plan.json
EOF
}

dry_run=false
force=false
plan_file=""

while [[ $# -gt 0 ]]; do
  case "$1" in
    --dry-run)
      dry_run=true
      shift
      ;;
    --force)
      force=true
      shift
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    -*)
      echo "Unknown option: $1" >&2
      usage
      exit 2
      ;;
    *)
      plan_file="$1"
      shift
      ;;
  esac
done

if [[ -z "$plan_file" ]]; then
  echo "Error: Plan file required" >&2
  usage
  exit 2
fi

if [[ ! -f "$plan_file" ]]; then
  echo "Error: Plan file not found: $plan_file" >&2
  exit 1
fi

# Validate JSON
if ! jq empty "$plan_file" 2>/dev/null; then
  echo "Error: Invalid JSON in plan file" >&2
  exit 1
fi

plan=$(cat "$plan_file")
source_dir=$(echo "$plan" | jq -r '.source_dir')
dest_dir=$(echo "$plan" | jq -r '.dest_dir')
content_type=$(echo "$plan" | jq -r '.type')
title=$(echo "$plan" | jq -r '.title')

echo "Executing rename plan for: $title ($content_type)"
echo "Source: $source_dir"
echo "Destination: $dest_dir"
echo ""

# Track results
success_count=0
skip_count=0
error_count=0
errors=()

# Process each operation
while IFS= read -r op; do
  src=$(echo "$op" | jq -r '.source')
  dest=$(echo "$op" | jq -r '.destination')
  category=$(echo "$op" | jq -r '.category')

  # Get relative paths for display
  src_name=$(basename "$src")
  dest_rel=${dest/#$HOME/\~}

  if [[ "$dry_run" == "true" ]]; then
    echo "[DRY-RUN] $src_name -> $dest_rel"
    success_count=$((success_count + 1))
    continue
  fi

  # Check if source exists
  if [[ ! -f "$src" ]]; then
    echo "[ERROR] Source not found: $src_name"
    errors+=("Source not found: $src")
    error_count=$((error_count + 1))
    continue
  fi

  # Check if destination exists
  if [[ -f "$dest" ]]; then
    if [[ "$force" == "true" ]]; then
      echo "[OVERWRITE] $src_name -> $dest_rel"
    else
      echo "[SKIP] Destination exists: $dest_rel"
      skip_count=$((skip_count + 1))
      continue
    fi
  fi

  # Create destination directory
  dest_parent=$(dirname "$dest")
  if ! mkdir -p "$dest_parent" 2>/dev/null; then
    echo "[ERROR] Failed to create directory: $dest_parent"
    errors+=("Failed to create directory: $dest_parent")
    error_count=$((error_count + 1))
    continue
  fi

  # Move the file
  if mv "$src" "$dest" 2>/dev/null; then
    echo "[OK] $src_name -> $dest_rel"
    success_count=$((success_count + 1))
  else
    echo "[ERROR] Failed to move: $src_name"
    errors+=("Failed to move: $src to $dest")
    error_count=$((error_count + 1))
  fi

done < <(echo "$plan" | jq -c '.operations[]')

echo ""
echo "=== Summary ==="
echo "Successful: $success_count"
echo "Skipped: $skip_count"
echo "Errors: $error_count"

if [[ ${#errors[@]} -gt 0 ]]; then
  echo ""
  echo "Errors:"
  for err in "${errors[@]}"; do
    echo "  - $err"
  done
fi

# Output result as JSON for programmatic use
if [[ "$dry_run" == "false" ]]; then
  jq -n \
    --argjson success "$success_count" \
    --argjson skipped "$skip_count" \
    --argjson errors "$error_count" \
    --arg source_dir "$source_dir" \
    --arg dest_dir "$dest_dir" \
    '{
      success_count: $success,
      skipped_count: $skipped,
      error_count: $errors,
      source_dir: $source_dir,
      dest_dir: $dest_dir
    }' >&2
fi

# Exit with error if any operations failed
[[ "$error_count" -eq 0 ]]
